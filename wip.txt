https://gymnasium.farama.org/tutorials/gymnasium_basics/environment_creation/ ? Heh, not at first, but be mindful that this should be possible later -> OFFER THIS IN A DEV WORKSHOP to rayane and benjamin, but I will code the game itself myself. YES ABSOLUTELY DO THAT.

Idea for map source for initial map : https://www.youtube.com/watch?v=DMJB8YODZaE northern part, in the bulge


If I use the "pendinng_orders" principle I likely don't need to ask input orders in the terminal typed directly :)

###### main.py #########

read_status_from_yaml
	the yaml contains min and max hex coordinates, the coordinates of hexes with defender bonuses or roads, the list of units at startup, and hexes which will receive reinforcements and at which turns, and which count for victory points

pending_orders : allows my framework to be easily used with AI ! a list containing pairs of (Unit, Hexagon). When requesting orders, we first check if any pending orders are present and try to execute those first. Orders are executed in FIFO, meaning you can queue movement orders for the same unit ! and ordering an unit to the hex it currently occupied is the same as a stay order
	note that we will iterate over pending_orders multiple times : first for the movement, then for the attacker combat, then for the defender allocation (the idea being that defender can pre-allocate support by order of priority, we simply skip an allocation if it is not necessary meaning no fight takes place here), etc.

while turn_counter < max_turns:

def execute_turn(self, pending_orders, player):

	REMEMBER TO PRINT LOG OF ALL OF THIS (noting every order, every dice roll, etc., AND HAVE A logger OBJECT TO OUTPUT ALL INTO A TEXT FILE)

		# First upkeep phase
		Refresh mobility for all units OF THE PLAYER

	# Movement phase
	Iterate over each unit (or ask to type a list of the IDs of units you want to move) : for each, check in pending orders and if none present request movement order to a nearby hex from user (which can be “stay”) until MP are exhausted
	Any stacked units are destroyed starting with the last arrived ones

	# Combat allocation phase
	Iterate over each unit (or ask to type a list of units that will attack) : for each , check if pending order if present and if not request attack order to an adjacent hex or to stay put
	Same for support, defender, etc.
		Which means that orders can be given with priority, see below

	# Resolution phase
	Resolve
	Prompt for retreats ; if no explicit order was given in pending_orders, retreat hexes are chosen at random if multiple are applicable
	print log of results

	# Advancing phase
	Iterate over each fight won and let attacker (or defender, if the attacker lost ) pick one unit to move there.
		if no explicit orders were given : if the attacker won, the attacker unit with strongest defensive power will be moved there and ties are broken at random. If the defender won, defending units don't budge without explicit orders

	# Second upkeep phase
	Then destroy all Fights and set mobility of all units to 0












class Map
	self.current_turn
	self.all_units : list<Unit>

	self.hexgrid : HexGrid
	self.ongoing_fights : list<Fight>

	def display()
		as a Pygame window

	def is_movement_valid(unit: Unit, hex) → to the hexgrid instead ? Unsure


	# Used in replay or in debug
	def _debug_force_movement(unit_id:int, destination_hex_x:int, destination_hex_y:int)
	def _debug_force_destruction(unit_id:int)
	def _debug_force_spawn(unit_type: str, hex_x:int, hex_y:int, player_side, unit_id)
		remember to check id is not already allocated


class Display()
	graphic functions go here

class Unit
	self.parent_map (we will need map functions that check if a move is valid)
	self.power, self.defense, self.mobility, self.range =
	#self.type = melee or support ; must be support if range is >1 and vice versa
	self.type = armored, etc.
	self.position : Hexagon
	self.mobility_remaining
	self.unique_id (CRUCIAL FOR SELECTION IN TYPED PROMPTS)

	self.attempt_move_to(hex):
		check if enough mobility remaining to move there, and if not occupied
		if in enemy zoc, set mobility to 0

	self.force_move_to(hex):
		used for retreats


	self.attempt_attack_on_hex(hex, map):
		check if we are within range of desired hex
		check if the hex contains an enemy unit

		#create a Fight if one does not already exist
		if map.all_fights does not have a fight on this hex :
			create a fight and join it
		else:
			join existing fight


	self.attempt_join_defense_on_hex(hex, map):
		check a fight exists at destination
        check we are within range to join it

class Fight
	self.attacking_player_id
	self.defending_player_id
	self.hexagon
	self.attacking_melee_units
	self.attacking_support
	self.defending_melee_unit
	self.defending_support

	def resolveFight():
		check attacker has at least one melee unit
		check who is in supply
		compute total strength
		compute ratio (remember that support units can be 0 so avoid divide-by-zero)
		check strength ratio for attacker is at least 0.5x defender
		determine result
		force retreats

	def check_possible_retreats:
		for all neighbor hexes, check if they are occupied by enemy units/zoc or impassable


class Hexagon:
    	self.q = q
    	self.r = r
    	self.defender_bonus
		self.mobility_cost_multiplier

	def self.is_accessible_to_player_side(side):
		check if the hex or its neighbors contains any unit NOT belonging to the specified side

class HexGrid:
    	self.hexagons = {}

	def add_hexagon:
    		self.hexagons[(q, r)] = Hexagon(q, r, characteristics)

	def get_hexagon(self, q, r):
    		return self.hexagons.get((q, r))

	def get_neighbors(self, q, r):
    		directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, 1)]
    		return [(q + dq, r + dr) for dq, dr in directions if (q + dq, r + dr) in self.hexagons]
		todo : change this code to cap to min and max q and r to avoid going offmap
		WARNING : use qr, or xy system ?? BE CAREFUL NOT TO MIX THE TWO !!


	# Below : used to trace a route to HQ
	# Hexes containing an enemy or which have a neighbor containing an enemy are considered inaccessible
	
	def build_graph(self):
    	G = nx.Graph()
    	for (q, r), hexagon in self.hexagons.items():
        	if not hexagon.accessible:
            	continue
        	for neighbor in self.get_neighbors(q, r):
            	if self.is_accessible(*neighbor):
                	G.add_edge((q, r), neighbor, weight=1)  # Weight can be adjusted if needed
    	return G

	def heuristic(self, a, b):
    	# Manhattan distance for hex grids
    	return abs(a[0] - b[0]) + abs(a[1] - b[1])

	def find_path(self, start, goal):
    	G = self.build_graph()
    	try:
        	path = nx.astar_path(G, start, goal, heuristic=self.heuristic, weight='weight')
        	return path
    	except nx.NetworkXNoPath:
        	return None
